# ES6 Нововведення

# Змінні: let і const

ES-2015 передбачає нові способи оголошення змінних: через `let` і `const` замість `var`.

Наприклад:
```js
let a = 5;
```

## let ##

У оголошенні змінної через `let` є три основні відмінності від `var`:

1. **Область видимості змінної `let` - блок коду, що обмежений фігурними дужками `{...}`**

    Змінну, оголошену через `var`, видно всюди в тілі функції,
    
    натомість, змінну, оголошену через `let`, видно лише в рамках блока `{...}`, в якому її оголошено.
    
    Це, зокрема, впливає на оголошення всередині керівних конструкцій `if`, `while` або `for`.
    
    Наприклад, змінна оголошена через `var`:
    
    ```js
    var apples = 5;
    
    if (true) {
        var apples = 10;
        
        alert(apples); // 10 (всередині блока)
    }
    
    alert(apples); // 10 (поза блоком те ж саме значення)
    ```
    
    У прикладі вище `apples` -- єдина змінна для всого коду, що модификується в `if`.
    
    Те ж саме з `let` буде працювати інакше:
    
    ```js
    let apples = 5; // (*)
    
    if (true) {
        let apples = 10;
        
        alert(apples); // 10 (всередині блока)
    }
    
    alert(apples); // 5 (назовні блока значення не змінилося)
    ```
    
    Тут, фактично, дві незалежні змінні `apples`, одна --- глобальна, друга -- в блоці `if`.
    
    Зауважимо, що якщо оголошення `let apples` в першрму рядку `(*)` видалити, то останній `alert` спровокує помилку: змінна не
    
оголошена:

    ```js
    if (true) {
        let apples = 10;
        
        alert(apples); // 10 (всередині блока)
    }
    
    alert(apples); // помилка!
    ```
    
    Через те, що змінну `let` завжди видно саме у тому блоці, де оголошено, і не більше.
    
2. **Змінну `let` видно лише після оголошення.**

    На противагу, змінні, оголошені через `var` існують і до оголошення. І дорівнюють `undefined`;
    
    ```js
    alert(a);
    
    var a = 5;
    ```
    
    Зі змінною `let` все набагато простіше. До оголошення їх взагалі не існує.
    
    Таке намагання отримати доступ до змінної, викличе помилку:
    
    ```js
    alert(a); // помилка, такої змінної не існує
    
    let a = 5;
    ```
    
    Зауважимо також, що змінні `let` не можна повторно оголошувати. Тобто, такий код призведе до помилки:
    
    ```js
    let x;
    let x; // помилка, змінна x вже оголошена
    ```
    
    Це -- хоч і виглядає певним обмеженням у порівнянні з `var`, проте насправді не створює жодних проблем. До прикладу, два таких цикли зовсім не конфліктують:
    
    ```js
    // кожен цикл має свою власну змінну i
    for (let i = 0; i<0; i++) { /* ... */ }
    for (let i = 0; i<0; i++) { /* ... */ }
    
    alert(i); // помилка, глобальної i не існує
    ```
    
    При оголошенні всередині циклу, змінну `i` буде видно лине в блоці циклу. Її не видно зовні, тому буде помилка в останньому `alert`.
    
3. **При використанні в циклі, для кожної ітерації створюється своя змінна.**

    Змінна `var` -- одна впродовж усіх ітерацій і її видно навіть по закінченню циклу:
    
    ```js
    for (var i = 0; i<10; i++) { /* ... */ }
    
    alert(i); // 10
    ```
    
    Зі змінною `let` -- все інакше.
    
    Кожному повторенню циклу відповідає своя незалежна змінна `let`. Якщо всередині циклу є вкладені оголошення функцій, то в замиканні
    кожної відповідної функції буде та змінна, корта була при відповідній ітерації.
    
    ```js
    function makeArmy() {
        let shooters = [];
        
        for (let i = 0; i<10; i++) {
            shooters.push(function () {
                alert(i);
            });
        }
        
        return shooters;
    }
    
    var army = makeArmy();
    
    army[0](); // 0
    army[5](); // 5
    ```
    
    Якби оголошення було `var i`, то була б одна змінна `1` на всю функцію, і виклики в останніх рядках виводили б `10`.
    
    А оголошення вище `let i` створює для кожного повторення блоку в циклі свою власну змінну, котру функція і отримує з замикання в останніх рядках.
    
## const

Оголошення `const` задає константу, себто змінну, яку не можна модифікувати:

```js
const apple = 5;
apple = 10; // помилка
```

В іншому оголошення `const` повністю збігається з `let`.

Зауважмо, що якщо в константу присвоєно об'єкт, то від змін захищена лише сама константа, а не властивості всередині неї:

```js
const user = {
    name: 'John',
};

user.name = 'Mitch'; // є доступ
user = 5; // не можна, буде помилка
```

Така ж буде відповідність, якщо константі буде присвоєно масив чи інше об'єктне значення.

```js
Константи, котрі жорстко задані завжди, впродовж всієї програми, зазвичай пишуться у верхньому реєстрі. До прикладу:
`const ORANGE = "#ffa500"`.

Більшість змінних -- константи у іншому сенсі: вони не змінюються після присвоєння. Проте при різних запусках функцій це значення може
бути різним. Тому для таких змінних можна використовувати `const` і звичайні малі літери в імені.
```

## У підсумку

Змінні `let`:

- Видно лише після оголошення і лише у поточному блоці.
- Не можна повторно оголошувати у тому ж блоці.
- При оголошенні в циклі `for (let ...)` - видно лише у цьому циклі. До того ж кожній ітерації буде відповідати своя незалежна змінна `let`.

Змінна `const` -- це константа, у всьому іншому -- як `let`.



